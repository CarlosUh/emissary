Emissary is a framework that facilitates flexible and fully configurable **electronic data interchange** (EDI) in a modular way, allowing non-engineers to implement complex file generation, security, and delivery strategies. 

We use this at Maxwell Health to translate and format data from our system into the various files that our carrier and integration partners can read. But Emissary is abstract enough that it can be used for any sort of "us-to-them" data delivery use case.

Emissary is not a standalone application. Rather, it should be part of a larger application and wrapped to fit your use case.

# Core Concepts
## The "Emissary"
A single Emissary (`*emissary.Emissary`) consists of configurations and modules that are used for file generation, security, and delivery. It has but two methods: `Run() error` will generate, secure, and deliver the file. `ShouldRun(time.Time) (bool, error)` parses the emissary's `Schedules` (cron syntax) to decide if it should be run at the provided time.

## Generator
A generator is any type that implements the `generator.FileGenerator` interface, which has one method: `Generate(io.Writer) error`. Any generator can make use of Emissary's `DataSource` to retrieve individual `DataMap`s, which implement a highly flexible syntax for data retrieval from arbitrary `map[string]interface{}`s. (see below)

## Security Module
A security module takes an `io.Reader`, which reads from the file generated by the `Generator`, and writes back to an `io.Writer`. Use cases for these are PGP or other encryption methods, which need the full file contents in order to encrypt them.

## Delivery Module
A delivery module takes an `io.Reader`, which reads from the generated file, and then performs an abstracted task (SFTP file drop, email, etc).

# EDL (Emissary Data Language)
This is a handlebars-esque templating language specifically built for non-engineers to format the result when retrieving a value from the `DataSource`. The `Get` method of the `DataMap` takes an EDL **key**, which is interpreted and then used to retrieve and format a value or values from the map. How you use the EDL is up to you (we let members of our services team configure each column of a spreadsheet report with EDL, which is passed verbatim to `DataMap.Get()`).

For a full list of examples, please see the test file (`/data/dataMap_test.go`).

## Dynamic Values
To get the value of an element in the map with dot notation, simply put a dollar sign ("$") in front of the key name. For example, if you have a map that looks like this:

```go
myMap := DataMap(map[string]interface{}{
	"foo":"bar",
	"baz":map[string]interface{}{
		"bing":"boop",
	},
})
```

You can retrieve the value of `baz.bing` with `myMap.Get("$baz.bing")`

Note that even if the retrieved value is not a string, the result will be the string-ified version of that value. Dates, for example, will end up as their RFC3339 format unless formatted otherwise, and numbers (floats, ints, etc) with 8 decimal places. Other types are passed directly to `fmt.Sprint`, so be careful.

## Formatting
You can format a static or dynamic value with the pipe operator ("|"). There are a few built-in formatters and it is very easy to add your own.

For example, to use the built-in currency formatter:

```go
myMap := DataMap(map[string]interface{}{
	"cost":1000,
})

stringCost := myMap.Get("$cost|currency") 
// "$1,000.00"
```

Some formatters take arguments, which you can provide via additional pipe operators:

```go
myMap := DataMap(map[string]interface{}{
	"date":time.Now(),
})

stringDate := myMap.Get("$date|date|2006-01-02") 
// "2015-03-21", at the time of this writing
```

### Formatters
* currency - adds commas, dollar sign prefix, and two decimal places w/ rounding
* substring - negative argument takes `n` characters from end of string, positive from beginning of string
* date - formats a date with first argument. See `time.Format` 

### Adding a Formatter
Just add another entry to the `data.Formatters` map, that is a function of type `Formatter`. The first piped argument will be passed to the formatter as `input`, and subsequent piped arguments will be passed as `arguments`.

## Multiple Dynamic Values
If you want to combine multiple dynamic values, with or without formatting, into the return value, you can surround them with curly braces. For example:

```go
myMap := DataMap(map[string]interface{}{
	"foo":"bar",
	"baz":map[string]interface{}{
		"bing":"boop",
	},
})

compoundVal := myMap.Get("{$foo|substring|2} --- {$baz.bing}")
// "ba --- boop"
```

## Conditional Statements
EDL has one type of conditional statement: the `IF/ELSE IF/ELSE` statement. These are implemented using a bbcode-esque syntax: `[IF {comparator} {args...}]...[ELSE IF {comparator} {args...}]...[ELSE]...[/IF]`

For example:

```go
myMap := DataMap(map[string]interface{}{
	"cost":1000,
})

conditionedVal := myMap.Get("[IF gt $cost 900]foo[ELSE]bar[/IF]")
// "foo"
```

Note that the arguments are separated by spaces by default. To have a single argument that contains a space, you must wrap it in double-quotes.

### Condition Operators
Note that for greater than/less than comparisons, values are intelligently parsed as either floats, dates, or strings, and compared accordingly.

* eq - equality (takes two arguments)
* neq - inequality (takes two arguments)
* in - containment. First argument is test, subsequent arguments make up the containment list
* nin - !containment. First argument is test, subsequent arguments make up the containment list
* gt - greater than. Takes two arguments and returns the result of ($1 > $2).
* gte - greater than or equal to. Takes two arguments and returns the result of ($1 >= $2).
* lt - less than. Takes two arguments and returns the result of ($1 < $2).
* lte - less than or equal to. Takes two arguments and returns the result of ($1 <= $2).

### Adding a Condition Operator
Add a new entry to the `data.ConditionOperators` map, that is a function of type `ConditionOperator`. The function gets passed a slice of `interface{}` types which are the parsed arguments within the block.

For example, in `[IF myOperator foo "foo bar" 10 2000-01-01T00:00:00Z]`, the `myOperator` condition operator will be passed `"foo"` (string), `"foo bar"` (string), `10.0` (float64), and `2000-01-01T00:00:00Z` (time.Time) as arguments.
